# A*算法解决二维迷宫问题
## 问题迷宫：
```
0 0 0 0 1 0 3 0 0 0
0 0 0 0 1 0 0 0 0 0
0 0 0 0 1 0 0 0 0 0
0 0 0 0 1 0 0 0 0 0
2 0 0 0 1 0 0 0 0 0
0 0 0 0 1 0 0 0 0 0
0 0 0 0 1 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
```
其中0表示可走，1表示不可走，2表示起点，3表示终点。  
实现通用的针对迷宫问题的Astar算法，解决本问题。
## 启发式函数
### 曼哈顿距离
以迷宫的左上角为原点，向下为x轴正方向，向右为y轴正方向，建立坐标系。

设(Xe, Ye)为目标终止位置，则对某一状态(Xi，Yi)，曼哈顿距离定义为：

> <center>mhd(E, I) = |Xe-Xi|+|Ye-Yi|</center>
### 代价函数
要奖励离终止节点更近的选择，要惩罚步数多的选择，且接近终止节点更应该受到奖励。  
故代价函数定义为：  
> <center>cost(E, I) = 2*mhd(E, I)+mhd(O, I)+depth(I)
其中I是第I步的节点坐标，E是目标节点坐标，O是初始节点坐标。  
总是选取cost小的节点作为下一个探索节点。采用优先队列，优化cost排序过程。
## 输出结果
输出相同大小的迷宫阵列，将横向走替换为横向箭头，纵向走替换为纵向箭头,对上述用例，输出结果为：
```
0 0 0 0 1 ↑ → 0 0 0
0 0 0 0 1 ↑ 0 0 0 0
0 0 0 0 1 ↑ 0 0 0 0
0 0 0 0 1 ↑ 0 0 0 0
2 → → → 1 ↑ 0 0 0 0
0 0 0 ↓ 1 ↑ 0 0 0 0
0 0 0 ↓ 1 ↑ 0 0 0 0
0 0 0 ↓ → → 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
```
## 附录
惩罚depth深的选择是十分重要的，否则会得到这样的解：
```
↑ → → → 1 ↑ → 0 0 0
↑ 0 0 ↓ 1 ↑ 0 0 0 0
↑ 0 0 ↓ 1 ↑ 0 0 0 0
↑ 0 0 ↓ 1 ↑ 0 0 0 0
2 0 0 ↓ 1 ↑ 0 0 0 0
0 0 0 ↓ 1 ↑ 0 0 0 0
0 0 0 ↓ 1 ↑ 0 0 0 0
0 0 0 ↓ → → 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
```
启发式算法先探索了起始点上方的点，如果不惩罚深度，深度优先搜索的选择将十分诱人。